### **第一阶段：创建并修改智能合约代码**

**目标**：将 `fabcar` 的Go语言合约，改造成我们需要的“数字证书”合约。

1. **进入 `chaincode` 目录** 打开终端，输入以下命令：
    
    Bash
    
    ```
    cd ~/hyperledger/fabric/scripts/fabric-samples/chaincode/
    ```
    
2. **复制 `go` 文件夹并重命名** 执行复制命令，创建你的项目文件夹 `certichain`：
    
    Bash
    
    ```
    cp -r fabcar/go/ ./certichain
    ```
    
3. **进入新目录并重命名合约文件**
    
    Bash
    
    ```
    cd certichain
    mv fabcar.go certichain.go
    ```
    
4. **修改合约代码 (`certichain.go`)** 使用编辑器打开 `certichain.go` 文件 (例如 `gedit certichain.go`)，开始修改核心代码。
    
    - **a. 修改数据结构**：找到 `Car` 结构体，将其**完全替换**为 `Certificate` 结构体。
        
        - **删除：**
            
            Go
            
            ```
            type Car struct {
                Make   string `json:"make"`
                Model  string `json:"model"`
                Colour string `json:"colour"`
                Owner  string `json:"owner"`
            }
            ```
            
        - **添加：**
            
            Go
            
            ```
            type Certificate struct {
                ID                 string `json:"id"`
                StudentName        string `json:"studentName"`
                StudentID          string `json:"studentId"`
                IssuingInstitution string `json:"issuingInstitution"`
                Degree             string `json:"degree"`
                IssueDate          string `json:"issueDate"`
            }
            ```
            
    - **b. 修改初始化函数 (`InitLedger`)**：这个函数用于预置一些测试数据。找到 `InitLedger` 函数，将其中的 `cars` 数据替换为证书数据。
        
        - **修改前 (部分代码)**：
            
            Go
            
            ```
            cars := []Car{
                {Make: "Toyota", Model: "Prius", Colour: "blue", Owner: "Tomoko"},
                // ... more cars
            }
            ```
            
        - **修改后：**
            
            Go
            
            ```
            certificates := []Certificate{
                {ID: "CERT01", StudentName: "Zhang San", StudentID: "S001", IssuingInstitution: "Zhejiang University", Degree: "Bachelor of Engineering", IssueDate: "2023-06-30"},
                {ID: "CERT02", StudentName: "Li Si", StudentID: "S002", IssuingInstitution: "Zhejiang University", Degree: "Master of Science", IssueDate: "2023-06-30"},
            }
            
            for _, cert := range certificates {
                certJSON, err := json.Marshal(cert)
                if err != nil {
                    return err
                }
            
                err = ctx.GetStub().PutState(cert.ID, certJSON)
                if err != nil {
                    return fmt.Errorf("failed to put to world state. %v", err)
                }
            }
            ```
            
    - **c. 修改创建函数 (`CreateCar` -> `CreateCertificate`)**：找到 `CreateCar` 函数，将其重命名并修改逻辑。
        
        - **修改前：** `func (s *SmartContract) CreateCar(...)`
            
        - **修改后：**
            
            Go
            
            ```
            func (s *SmartContract) CreateCertificate(ctx contractapi.TransactionContextInterface, id string, studentName string, studentId string, issuingInstitution string, degree string, issueDate string) error {
                exists, err := s.AssetExists(ctx, id) // 我们可以复用一个检查存在的函数
                if err != nil {
                    return err
                }
                if exists {
                    return fmt.Errorf("the certificate %s already exists", id)
                }
            
                cert := Certificate{
                    ID:                 id,
                    StudentName:        studentName,
                    StudentID:          studentId,
                    IssuingInstitution: issuingInstitution,
                    Degree:             degree,
                    IssueDate:          issueDate,
                }
                certJSON, err := json.Marshal(cert)
                if err != nil {
                    return err
                }
            
                return ctx.GetStub().PutState(id, certJSON)
            }
            ```
            
    - **d. 修改查询函数 (`QueryCar` -> `QueryCertificate`)**：找到 `QueryCar` 函数，将其重命名并修改。
        
        - **修改前：** `func (s *SmartContract) QueryCar(...)`
            
        - **修改后 (简化版)**：
            
            Go
            
            ```
            func (s *SmartContract) QueryCertificate(ctx contractapi.TransactionContextInterface, id string) (*Certificate, error) {
                certJSON, err := ctx.GetStub().GetState(id)
                if err != nil {
                    return nil, fmt.Errorf("failed to read from world state: %v", err)
                }
                if certJSON == nil {
                    return nil, fmt.Errorf("the certificate %s does not exist", id)
                }
            
                var cert Certificate
                err = json.Unmarshal(certJSON, &cert)
                if err != nil {
                    return nil, err
                }
            
                return &cert, nil
            }
            ```
            
    - **e. 修改查询所有函数 (`QueryAllCars` -> `QueryAllCertificates`)**：找到 `QueryAllCars`，将其重命名。内部逻辑主要是变量名的修改，查询范围可以暂时不变。
        
5. **更新依赖** 在 `certichain` 目录下打开终端，运行命令以确保依赖正确：
    
    Bash
    
    ```
    go mod tidy
    ```
    

### **第二阶段：部署全新的智能合约**

**目标**：将你修改好的 `certichain` 合约，完整地部署到测试网络上。**此部分完全复刻实验七的流程，只是替换了名称**。

1. **启动测试网络** 回到 `test-network` 目录，启动网络并创建通道。
    
    Bash
    
    ```
    cd ~/hyperledger/fabric/scripts/fabric-samples/test-network
    ./network.sh down
    ./network.sh up createChannel
    ```
    
2. **设置环境变量** 在**当前终端**中，设置必要的环境变量，为 Org1 操作做准备。
    
    Bash
    
    ```
    export PATH=${PWD}/../bin:$PATH
    export FABRIC_CFG_PATH=$PWD/../config/
    export CORE_PEER_TLS_ENABLED=true
    export CORE_PEER_LOCALMSPID="Org1MSP"
    export CORE_PEER_TLS_ROOTCERT_FILE=${PWD}/organizations/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt
    export CORE_PEER_MSPCONFIGPATH=${PWD}/organizations/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp
    export CORE_PEER_ADDRESS=localhost:7051
    ```
    
3. **打包新合约**
    
    Bash
    
    ```
    peer lifecycle chaincode package certichain.tar.gz --path ../chaincode/certichain --lang golang --label certichain_1
    ```
    
4. **安装新合约**
    
    - **为 Org1 安装**:
        
        Bash
        
        ```
        peer lifecycle chaincode install certichain.tar.gz
        ```
        
    - **切换到 Org2 并安装**:
        
        Bash
        
        ```
        export CORE_PEER_LOCALMSPID="Org2MSP"
        export CORE_PEER_TLS_ROOTCERT_FILE=${PWD}/organizations/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt
        export CORE_PEER_MSPCONFIGPATH=${PWD}/organizations/peerOrganizations/org2.example.com/users/Admin@org2.example.com/msp
        export CORE_PEER_ADDRESS=localhost:9051
        peer lifecycle chaincode install certichain.tar.gz
        ```
        
5. **批准新合约**
    
    - **查询 Package ID**:
        
        Bash
        
        ```
        peer lifecycle chaincode queryinstalled
        ```
        
        你会看到类似 `Package ID: certichain_1:xxxxxxxx...` 的输出，**复制这一整行 ID**。
        
    - **设置 Package ID 环境变量**:
        
        Bash
        
        ```
        export CC_PACKAGE_ID=粘贴你复制的PackageID
        ```
        
    - **Org2 批准**:
        
        Bash
        
        ```
        peer lifecycle chaincode approveformyorg -o localhost:7050 --ordererTLSHostnameOverride orderer.example.com --channelID mychannel --name certichain --version 1.0 --package-id $CC_PACKAGE_ID --sequence 1 --tls --cafile "${PWD}/organizations/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem"
        ```
        
    - **切换回 Org1 并批准**:
        
        Bash
        
        ```
        export CORE_PEER_LOCALMSPID="Org1MSP"
        export CORE_PEER_TLS_ROOTCERT_FILE=${PWD}/organizations/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt
        export CORE_PEER_MSPCONFIGPATH=${PWD}/organizations/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp
        export CORE_PEER_ADDRESS=localhost:7051
        peer lifecycle chaincode approveformyorg -o localhost:7050 --ordererTLSHostnameOverride orderer.example.com --channelID mychannel --name certichain --version 1.0 --package-id $CC_PACKAGE_ID --sequence 1 --tls --cafile "${PWD}/organizations/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem"
        ```
        
6. **提交新合约到通道**
    
    Bash
    
    ```
    peer lifecycle chaincode commit -o localhost:7050 --ordererTLSHostnameOverride orderer.example.com --channelID mychannel --name certichain --version 1.0 --sequence 1 --tls --cafile "${PWD}/organizations/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem" --peerAddresses localhost:7051 --tlsRootCertFiles "${PWD}/organizations/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt" --peerAddresses localhost:9051 --tlsRootCertFiles "${PWD}/organizations/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt"
    ```
    

### **第三阶段：在命令行中测试合约**

**目标**：验证你的新合约是否能正常工作。

1. **调用 `InitLedger`** 调用初始化函数，写入两条预设的证书数据。
    
    Bash
    
    ```
    peer chaincode invoke -o localhost:7050 --ordererTLSHostnameOverride orderer.example.com --tls --cafile "${PWD}/organizations/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem" -C mychannel -n certichain --peerAddresses localhost:7051 --tlsRootCertFiles "${PWD}/organizations/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt" --peerAddresses localhost:9051 --tlsRootCertFiles "${PWD}/organizations/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt" -c '{"function":"InitLedger","Args":[]}'
    ```
    
    如果成功，会看到 `status:200` 的返回。
    
2. **调用 `QueryCertificate`** 查询刚刚初始化时写入的一条证书数据。
    
    Bash
    
    ```
    peer chaincode query -C mychannel -n certichain -c '{"function":"QueryCertificate","Args"
    ```